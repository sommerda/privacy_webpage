#!/usr/bin/env python2.7

import sys
sys.path.insert(0, "../")
from matplotlib import pyplot as plt
#from core.tools import eps_of_delta_for_ed
from bounds.renyi_privacy import renyi_delta_of_eps
from core.tools import include_dist_events
import numpy as np
from math import sqrt
from math import exp
from math import pi
from math import log


class ConcentratedDP:
    def __init__(self, xi, rho, tolerance = 10**-7, epss = np.linspace(0,4,2000), initial_value = 0, bound_low = None):
        self.xi = xi
        self.rho = rho
        self.tolerance = tolerance
        self.epss = epss
        self.initial_value = initial_value
        self.bound_low = bound_low if bound_low is not None else self.initial_value
        self.nr_of_composition = 0


    # returns the following delta for a given eps, if eps >= xi + rho: delta =
    ##                   2
    ##  -(eps - xi - rho)
    ##  ------------------
    ##      4 rho                                                2
    ## e                   *  --------------------------------------------------------------------
    ##                             eps - xi - rho          --------------------------------------
    ##                        1 +  -------------- + --    /                       2              \
    ##                                  2 rho      /  \  /  (     eps - xi - rho )         4
    ##                                                \ /   ( 1 + -------------- )   +   ------
    ##                                                \/    (         2 rho      )       pi rho
    ##
    def delta_of_eps_3(self, eps):
        xi = self.xi
        rho = self.rho
        if eps < rho + xi:
            return 1.0
        else:
            return exp(-(eps - xi - rho)**2/float(4 * rho)) * 2 / \
                    float(1 + (eps - xi - rho)/float(2 * rho) \
                        + sqrt((1 + (eps - xi - rho)/float(2 * rho))**2 + 4/float(pi * rho)))

    # returns the following delta for a given eps, if eps >= xi + rho: delta =
    ##                   2
    ##  -(eps - xi - rho)
    ##  ------------------
    ##      4 rho                       1
    ## e                   *  --------------------
    ##                             eps - xi - rho
    ##                        1 +  --------------
    ##                                  2 rho
    ##
    def delta_of_eps_2(self, eps):
        xi = self.xi
        rho = self.rho
        if eps < rho + xi:
            return 1.0
        else:
            return exp(-(eps - xi - rho)**2/float(4 * rho)) / \
                    float(1 + (eps - xi - rho)/float(2 * rho))

    # for (alpha, D_alpha) compute (eps, min_alpha (exp(D_alpha * alpha - alpha * eps))
    def delta_of_eps_1(self, eps):
        d_alpha = lambda alpha: self.xi + alpha * self.rho
        return renyi_delta_of_eps(eps, d_alpha)

    def delta_of_eps(self, eps, delta_dist_0 = 0):
        return include_dist_events(min(self.delta_of_eps_3(eps), min(self.delta_of_eps_2(eps), self.delta_of_eps_1(eps))), delta_dist_0, self.nr_of_composition)

    def eps_of_3(self, delta):
        return eps_of_delta_for_ed(delta, self.delta_of_eps_3, tolerance = self.tolerance)

        # f = lambda eps: abs(delta - self.delta_of_eps_3(eps))
        # opt_res = minimize(f, [self.initial_value], bounds=[(self.bound_low, None)])
        # return opt_res.x[0]

        # distance = 10**10
        # candidate = 10**10
        # for eps in self.epss: #[eps for eps in self.epss if eps >= self.xi + self.rho]:
        #     new_distance = abs(self.delta_of_eps_3(eps) - delta)
        #     if new_distance <= distance:
        #         distance = new_distance
        #         candidate = eps
        #     else:
        #         # assume in x_plot e^eps is monotonically increasing, e.g., if file is generated by PB
        #         # add the last point to over-approximate e^eps
        #         candidate = eps
        #         break
        # return candidate


    def eps_of_2(self, delta):
        return eps_of_delta_for_ed(delta, self.delta_of_eps_2, tolerance = self.tolerance)

        # f = lambda eps: abs(delta - self.delta_of_eps_2(eps))
        # opt_res = minimize(f, [self.initial_value], bounds=[(self.bound_low, None)], tol=1e-7)
        # return opt_res.x[0]

        # distance = 10**10
        # candidate = 10**10
        # for eps in self.epss: #[eps for eps in self.epss if eps >= self.xi + self.rho]:
        #     new_distance = abs(self.delta_of_eps_2(eps) - delta)
        #     if new_distance <= distance:
        #         distance = new_distance
        #         candidate = eps
        #     else:
        #         # assume in x_plot e^eps is monotonically increasing, e.g., if file is generated by PB
        #         # add the last point to over-approximate e^eps
        #         candidate = eps
        #         break
        # return candidate

    def eps_of_1(self, delta):
        xi = self.xi
        rho = self.rho
        if sqrt(pi * rho) >= 1:
            return xi + rho + sqrt(4 * rho  * log(sqrt(pi * rho)/float(delta)))
        else:
            return xi + rho + sqrt(4 * rho  * log(1/float(delta)))

    def eps_of(self, delta):
        # return self.eps_of_1(delta)
        return min(self.eps_of_3(delta), min(self.eps_of_2(delta), self.eps_of_1(delta)))

    def draw_ed_graph(self, deltas = np.linspace(1,0.0001,2000)):
        res = [self.eps_of(delta) for delta in deltas]
        return [res, deltas]

    @classmethod
    def rho_of_gaussian(cls, mean_difference, sigma):
        return mean_difference**2/float(2 * sigma**2)

    @classmethod
    def from_gaussians(cls, mean_difference, sigma):
        return cls(xi = 0, rho = cls.rho_of_gaussian(mean_difference, sigma), epss = np.linspace(1,60,6000))

    def compose_with(self, instance):
        self.xi += instance.xi
        self.rho += instance.rho
        self.nr_of_composition = self.nr_of_composition + instance.nr_of_composition

    # compute A^(2^k)
    def self_compose_iterated_squaring(self, k):
        for i in range(k):
            self.compose_with(self)


if __name__ == '__main__':
    mean_difference = 1
    sigma = sqrt(2) * 200
    k = 9
    rho = ConcentratedDP.rho_of_gaussian(mean_difference,sigma)
    instance = ConcentratedDP(xi = 0, rho = rho, tolerance = 10**-5, epss = np.linspace(0.0000001,0.5,10000), initial_value = 0.0001, bound_low = 0)
    instance.self_compose_iterated_squaring(k)
    print("Testing the class ConcentratedDP with")
    print("  mean difference = " + str(mean_difference) + ", sigma = " + str(sigma) + ", for " + str(2**k) + " compositions.")
    plt.plot(instance.epss, [instance.delta_of_eps_3(eps) for eps in instance.epss], label="delta_of_eps_3", alpha = 0.5)
    plt.plot(instance.epss, [instance.delta_of_eps_2(eps) for eps in instance.epss], label="delta_of_eps_2", alpha = 0.5, linestyle='dashed')
    deltas = np.linspace(1,0.0001,2000)
    plt.plot([instance.eps_of_1(delta) for delta in deltas], deltas, label="eps_of_1", alpha = 0.5)
    plt.plot([instance.eps_of_2(delta) for delta in deltas], deltas, label="eps_of_2", alpha = 0.5)
    plt.plot([instance.eps_of_3(delta) for delta in deltas], deltas, label="eps_of_3", alpha = 0.5,linestyle='dashed')
    plot = instance.draw_ed_graph(deltas = deltas)
    plt.plot(plot[0],plot[1], label="draw_ed_graph", alpha = 0.5, linestyle='dotted')
    plt.plot([instance.xi + instance.rho],[0],marker='x')
    plt.xlabel(r'$\varepsilon$')
    plt.ylabel(r'$\delta$')
    plt.legend(bbox_to_anchor=(0.6, 0.99), loc=2, borderaxespad=0.)
    plt.show()
    exit(0)
